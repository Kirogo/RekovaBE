// controllers/paymentController.js - COMPLETE CORRECTED VERSION

const cron = require('node-cron');
const Transaction = require('../models/Transaction');
const Customer = require('../models/Customer');
const {
  formatPhoneNumber,
  isValidKenyanPhone,
  calculateNewBalances
} = require('../utils/helpers');
const WhatsAppService = require('../services/whatsappService');

console.log('üîß Loading payment controller...');

/*
 * @desc    Initiate STK Push payment
 * @route   POST /api/payments/initiate
 * @access  Private (Admin, Supervisor, Agent)
 */
exports.initiateSTKPush = async (req, res) => {
  console.log('\n=== INITIATE PAYMENT REQUEST ===');
  console.log('Request body:', req.body);
  console.log('User:', req.user?.username);

  const session = await Transaction.startSession();
  session.startTransaction();

  try {
    const { phoneNumber, amount, description = 'Loan Repayment', customerId } = req.body;

    // Validation
    if (!phoneNumber || !amount) {
      console.log('‚ùå Validation failed: Missing phone or amount');
      await session.abortTransaction();
      session.endSession();
      return res.status(400).json({
        success: false,
        message: 'Please provide phone number and amount'
      });
    }

    const amountNum = parseFloat(amount);
    if (isNaN(amountNum) || amountNum <= 0) {
      console.log('‚ùå Validation failed: Invalid amount', amount);
      await session.abortTransaction();
      session.endSession();
      return res.status(400).json({
        success: false,
        message: 'Please provide a valid amount greater than 0'
      });
    }

    // Format and validate phone number
    const formattedPhone = formatPhoneNumber(phoneNumber);
    console.log('Formatted phone:', formattedPhone);

    if (!isValidKenyanPhone(formattedPhone)) {
      console.log('‚ùå Validation failed: Invalid Kenyan phone', formattedPhone);
      await session.abortTransaction();
      session.endSession();
      return res.status(400).json({
        success: false,
        message: 'Please provide a valid Kenyan phone number'
      });
    }

    // Find customer
    let customer;
    if (customerId) {
      console.log('Looking for customer by ID:', customerId);
      customer = await Customer.findOne({
        $or: [
          { _id: customerId },
          { customerId: customerId }
        ],
        isActive: true
      }).session(session);
    }

    if (!customer) {
      console.log('Looking for customer by phone:', formattedPhone);
      customer = await Customer.findOne({
        phoneNumber: formattedPhone,
        isActive: true
      }).session(session);
    }

    if (!customer) {
      console.log('‚ùå Customer not found');
      await session.abortTransaction();
      session.endSession();
      return res.status(404).json({
        success: false,
        message: 'Customer not found. Please register customer first.'
      });
    }

    console.log('‚úÖ Customer found:', customer.name);

    // Check loan balance
    if (amountNum > customer.loanBalance) {
      console.log('‚ùå Amount exceeds loan balance');
      await session.abortTransaction();
      session.endSession();
      return res.status(400).json({
        success: false,
        message: `Payment amount (Ksh ${amountNum.toLocaleString()}) exceeds loan balance (Ksh ${customer.loanBalance.toLocaleString()})`
      });
    }

    // Generate transaction IDs - SIMPLE VERSION (No static method calls)
    const transactionId = `TRX${Date.now().toString().slice(-10)}${Math.floor(Math.random() * 1000).toString().padStart(3, '0')}`;
    const transactionInternalId = `TRN${Date.now().toString().slice(-8)}${Math.floor(Math.random() * 1000).toString().padStart(3, '0')}`;

    console.log('Generated Transaction ID:', transactionId);

    // Calculate new balances
    const { newLoanBalance, newArrears } = calculateNewBalances(customer, amountNum);
    console.log('New balances - Loan:', newLoanBalance, 'Arrears:', newArrears);

    // Create transaction
    console.log('Creating transaction...');
    const transactionData = {
      transactionInternalId,
      transactionId,
      customerId: customer._id,
      customerInternalId: customer.customerInternalId || customer.customerId,
      phoneNumber: formattedPhone,
      amount: amountNum,
      description,
      status: 'PENDING',
      loanBalanceBefore: customer.loanBalance,
      loanBalanceAfter: newLoanBalance,
      arrearsBefore: customer.arrears,
      arrearsAfter: newArrears,
      paymentMethod: 'WHATSAPP',
      initiatedBy: req.user.username,
      initiatedByUserId: req.user.id,
      whatsappRequest: {
        message: 'WhatsApp payment request sent',
        timestamp: new Date()
      },
      pinAttempts: 0
    };

    const transaction = await Transaction.create([transactionData], { session });

    await session.commitTransaction();
    session.endSession();

    console.log('‚úÖ Transaction created:', transaction[0]._id);

    // Send WhatsApp message
    console.log('Sending WhatsApp message...');
    let whatsappResponse = null;
    try {
      whatsappResponse = await WhatsAppService.sendPaymentRequest(
        formattedPhone,
        customer.name,
        amountNum,
        transactionId
      );

      console.log('WhatsApp response:', whatsappResponse);

      // Update transaction with WhatsApp info
      await Transaction.findByIdAndUpdate(transaction[0]._id, {
        whatsappMessageId: whatsappResponse.messageId,
        whatsappStatus: whatsappResponse.status,
        'whatsappRequest.sentAt': new Date(),
        'whatsappRequest.mock': whatsappResponse.mock || false
      }, { session: null });

    } catch (whatsappError) {
      console.error('‚ùå WhatsApp sending failed in controller:', whatsappError.message);
      whatsappResponse = {
        success: false,
        error: whatsappError.message,
        mock: true
      };

      // Update transaction as failed to send
      await Transaction.findByIdAndUpdate(transaction[0]._id, {
        status: 'FAILED',
        errorMessage: `WhatsApp message failed: ${whatsappError.message}`,
        whatsappStatus: 'FAILED'
      }, { session: null });
    }

    console.log('‚úÖ Sending response to frontend');
    res.json({
      success: true,
      message: whatsappResponse.mock ?
        'Payment request created (WhatsApp in mock mode)' :
        'Payment request sent successfully via WhatsApp',
      data: {
        transaction: transaction[0],
        customer: {
          name: customer.name,
          phoneNumber: customer.phoneNumber,
          loanBalanceBefore: customer.loanBalance,
          loanBalanceAfter: newLoanBalance,
          arrearsBefore: customer.arrears,
          arrearsAfter: newArrears
        },
        whatsapp: whatsappResponse
      }
    });

  } catch (error) {
    console.error('‚ùå‚ùå‚ùå CRITICAL ERROR in initiateSTKPush:');
    console.error('Error name:', error.name);
    console.error('Error message:', error.message);
    console.error('Error stack:', error.stack);
    console.error('Error code:', error.code);

    await session.abortTransaction();
    session.endSession();

    if (error.code === 11000 && error.keyPattern?.transactionId) {
      console.log('Duplicate transaction ID');
      return res.status(409).json({
        success: false,
        message: 'Transaction ID conflict. Please try again.'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Server error: ' + error.message,
      error: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
};

// ==================== WHATSAPP PAYMENT PROCESSING ====================

/**
 * @desc    Process WhatsApp payment response
 * @route   POST /api/payments/whatsapp-response
 * @access  Public (Called by Twilio webhook)
 */
exports.processWhatsAppResponse = async (req, res) => {
  console.log('\nüì± WHATSAPP WEBHOOK RECEIVED');
  console.log('Request body:', JSON.stringify(req.body, null, 2));

  // Send immediate response to Twilio
  res.set('Content-Type', 'text/xml');

  try {
    const { From, Body, MessageSid } = req.body;

    if (!From || !Body) {
      console.log('Missing From or Body in webhook');
      return res.send('<Response></Response>');
    }

    // Extract phone number (remove 'whatsapp:+')
    const phoneNumber = From.replace('whatsapp:+', '');
    console.log('Processing response from:', phoneNumber);
    console.log('Message body:', Body);

    // Clean and trim the message
    const message = Body.trim();
    console.log('Cleaned message:', message);

    // Check for PIN 1234 in various formats
    let pin = null;

    // SIMPLIFIED LOGIC: Just check if message contains "1234"
    if (message === '1234') {
      pin = '1234';
      console.log('‚úÖ Exact PIN 1234 received');
    }
    // Check if message contains "1234" anywhere
    else if (message.includes('1234')) {
      pin = '1234';
      console.log('‚úÖ PIN 1234 found in message');
    }
    // Check for "confirm" or "yes" (case-insensitive)
    else if (message.toLowerCase().includes('confirm') ||
      message.toLowerCase().includes('yes') ||
      message.toLowerCase().includes('ok')) {
      pin = '1234';
      console.log('‚úÖ Confirmation received, using PIN 1234');
    }
    // Check for "pay" followed by numbers
    else if (message.toLowerCase().startsWith('pay')) {
      // Extract numbers after "pay"
      const numbers = message.replace(/\D/g, '');
      if (numbers === '1234') {
        pin = '1234';
        console.log('‚úÖ PAY 1234 received');
      }
    }

    console.log('PIN extracted:', pin);

    if (!pin) {
      console.log('No valid PIN found, sending instructions');
      // Send helpful message back
      const responseMessage = `For demo purposes, please reply with:\n\n‚Ä¢ "1234" (to confirm payment)\n‚Ä¢ Or "CONFIRM" or "YES"\n\nThis will process your payment of ${transaction?.amount ? `KES ${transaction.amount.toLocaleString()}` : 'the requested amount'}.`;

      const twimlResponse = `
        <Response>
          <Message>${responseMessage}</Message>
        </Response>
      `;
      return res.send(twimlResponse);
    }

    // Find the most recent pending transaction for this phone number
    let transaction = await Transaction.findOne({
      phoneNumber: phoneNumber,
      status: 'PENDING'
    }).sort({ createdAt: -1 });

    // If not found by phone, try customer lookup
    if (!transaction) {
      console.log('No transaction found by phone, trying customer lookup...');
      const customer = await Customer.findOne({
        phoneNumber: phoneNumber
      });

      if (customer) {
        transaction = await Transaction.findOne({
          customerId: customer._id,
          status: 'PENDING'
        }).sort({ createdAt: -1 });
      }
    }

    if (!transaction) {
      console.log('No pending transaction found for:', phoneNumber);
      // Send message to customer
      const twimlResponse = `
        <Response>
          <Message>No pending payment request found. Please initiate a new payment request from the agent.</Message>
        </Response>
      `;
      return res.send(twimlResponse);
    }

    console.log('Found transaction:', transaction.transactionId);
    console.log('Transaction amount:', transaction.amount);
    console.log('Processing with PIN:', pin);

    // Process the payment
    const success = await processPaymentWithPIN(transaction, pin);

    if (success) {
      console.log('Payment sent');
      // Send success confirmation
      const twimlResponse = `
        <Response>
          <Message>Dear ${customerName}, your MPESA transfer of KES ${transaction.amount.toLocaleString()} has been processed successfully. MPESA Ref Number: ${transaction.mpesaReceiptNumber}</Message>
        </Response>
      `;
      return res.send(twimlResponse);
    } else {
      console.log('Payment processing failed');
      // Send failure message
      const twimlResponse = `
        <Response>
          <Message>‚ùå Payment processing failed. Please contact support.</Message>
        </Response>
      `;
      return res.send(twimlResponse);
    }

  } catch (error) {
    console.error('WhatsApp webhook error:', error);
    res.status(500).send('<Response><Message>Internal server error</Message></Response>');
  }
};

// Helper function to process payment with PIN
async function processPaymentWithPIN(transaction, pin) {
  try {
    console.log(`\nüí∞ PROCESSING PAYMENT FOR TRANSACTION: ${transaction.transactionId}`);
    console.log('PIN received:', pin);
    console.log('PIN type:', typeof pin);
    console.log('PIN === "1234":', pin === '1234');

    // SPECIAL FIX: Only accept PIN "1234" for demo
    if (pin !== '1234') {
      console.log('‚ùå Invalid PIN. Only 1234 is accepted.');
      console.log('Actual PIN received:', pin);

      // Increment pin attempts
      transaction.pinAttempts += 1;
      transaction.updatedAt = new Date();

      // Check if max attempts reached
      if (transaction.pinAttempts >= 3) {
        transaction.status = 'FAILED';
        transaction.errorMessage = 'Maximum PIN attempts exceeded';
        transaction.failureReason = 'WRONG_PIN';
      }

      await transaction.save();

      return false;
    }

    // Start a new session for database transaction
    const session = await Transaction.startSession();

    try {
      await session.startTransaction();

      // Generate receipt number
      let mpesaReceiptNumber;
      try {
        // If Transaction has generateMpesaReceiptNumber method
        if (typeof Transaction.generateMpesaReceiptNumber === 'function') {
          mpesaReceiptNumber = Transaction.generateMpesaReceiptNumber();
        } else {
          // Fallback
          mpesaReceiptNumber = `MPESA${Date.now().toString().slice(-8)}${Math.floor(Math.random() * 10000).toString().padStart(4, '0')}`;
        }
      } catch (error) {
        // Another fallback
        mpesaReceiptNumber = `RC${Date.now().toString().slice(-10)}`;
      }

      console.log('Generated receipt:', mpesaReceiptNumber);

      // Update transaction
      transaction.status = 'SUCCESS';
      transaction.mpesaReceiptNumber = mpesaReceiptNumber;
      transaction.processedAt = new Date();
      transaction.updatedAt = new Date();
      transaction.pinAttempts += 1;
      transaction.paymentMethod = 'WHATSAPP';
      transaction.whatsappResponse = {
        receivedAt: new Date(),
        pinReceived: true,
        pinDigits: pin.length,
        messageId: 'whatsapp_webhook'
      };

      // Save transaction within session
      await transaction.save({ session });

      // Update customer
      // In paymentController.js - Update the customer save section:

      // Update customer
      // In processPaymentWithPIN function - Update the customer save section:

      // Update customer
      const customer = await Customer.findById(transaction.customerId).session(session);
      if (customer) {
        console.log(`Updating customer: ${customer.name}`);

        // Use the pre-calculated balances from the transaction
        customer.loanBalance = transaction.loanBalanceAfter;
        customer.arrears = transaction.arrearsAfter;
        customer.totalRepayments += transaction.amount;
        customer.lastPaymentDate = new Date();
        customer.updatedAt = new Date();

        // FIX: Use updateOne to avoid middleware issues
        await Customer.updateOne(
          { _id: customer._id },
          {
            $set: {
              loanBalance: customer.loanBalance,
              arrears: customer.arrears,
              totalRepayments: customer.totalRepayments,
              lastPaymentDate: customer.lastPaymentDate,
              updatedAt: customer.updatedAt
            }
          },
          { session }
        );

        console.log(`‚úÖ Customer ${customer.name} balance updated`);
        console.log(`New loan balance: ${customer.loanBalance}`);
        console.log(`New arrears: ${customer.arrears}`);
      } else {
        console.log('‚ùå Customer not found for transaction');
      }

      // Commit the transaction
      await session.commitTransaction();
      console.log(`‚úÖ Database transaction committed`);

      console.log(`Payment successful! Receipt: ${mpesaReceiptNumber}`);
      console.log(`Transaction ${transaction.transactionId} marked as SUCCESS`);

      // Send receipt via WhatsApp
      try {
        await WhatsAppService.sendPaymentReceipt(
          transaction.phoneNumber,
          transaction
        );
        console.log('‚úÖ Receipt sent via WhatsApp');
      } catch (receiptError) {
        console.error('Failed to send receipt:', receiptError.message);
        // Don't fail the whole process if receipt sending fails
      }

      return true;

    } catch (error) {
      await session.abortTransaction();
      console.error('Transaction error:', error);
      throw error;
    } finally {
      session.endSession();
    }

  } catch (error) {
    console.error('‚ùå Error in processPaymentWithPIN:', error);
    return false;
  }
}

// ==================== MANUAL PIN ENTRY ====================

/**
 * @desc    Manual PIN entry for testing
 * @route   POST /api/payments/manual-pin
 * @access  Private
 */
exports.manualPinEntry = async (req, res) => {
  console.log('\nüîë MANUAL PIN ENTRY REQUEST');
  console.log('Request body:', req.body);

  try {
    const { transactionId, pin } = req.body;

    if (!transactionId || !pin) {
      return res.status(400).json({
        success: false,
        message: 'Please provide transaction ID and PIN'
      });
    }

    // SPECIAL FIX: Only accept 1234 for demo
    if (pin !== '1234') {
      return res.status(400).json({
        success: false,
        message: '‚ùå For demo purposes, please use PIN: 1234'
      });
    }

    // Find transaction
    const transaction = await Transaction.findOne({
      transactionId: transactionId,
      status: 'PENDING'
    });

    if (!transaction) {
      console.log('‚ùå Transaction not found or not pending:', transactionId);
      return res.status(404).json({
        success: false,
        message: 'Pending transaction not found'
      });
    }

    console.log(`Found transaction for: ${transaction.phoneNumber}`);
    console.log(`Transaction amount: ${transaction.amount}`);

    // Process payment
    const success = await processPaymentWithPIN(transaction, pin);

    if (success) {
      // Get updated transaction
      const updatedTransaction = await Transaction.findOne({ transactionId: transactionId });

      res.json({
        success: true,
        message: 'Payment processed successfully!',
        data: {
          receipt: updatedTransaction.mpesaReceiptNumber,
          amount: updatedTransaction.amount,
          transactionId: updatedTransaction.transactionId,
          newLoanBalance: updatedTransaction.loanBalanceAfter,
          newArrears: updatedTransaction.arrearsAfter,
          status: updatedTransaction.status
        }
      });
    } else {
      // Get updated transaction to check status
      const updatedTransaction = await Transaction.findOne({ transactionId: transactionId });

      res.status(400).json({
        success: false,
        message: '‚ùå Payment failed',
        data: {
          status: updatedTransaction?.status || 'FAILED',
          errorMessage: updatedTransaction?.errorMessage || 'Payment processing failed'
        }
      });
    }

  } catch (error) {
    console.error('‚ùå Manual PIN endpoint error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error: ' + error.message
    });
  }
};

// ==================== OTHER FUNCTIONS ====================

/**
 * @desc    Process MPesa PIN
 * @route   POST /api/payments/process-pin
 * @access  Private (Admin, Supervisor, Agent)
 */
exports.processPin = async (req, res) => {
  const session = await Transaction.startSession();
  session.startTransaction();

  try {
    const { transactionId, pin } = req.body;

    if (!transactionId || !pin) {
      await session.abortTransaction();
      session.endSession();
      return res.status(400).json({
        success: false,
        message: 'Please provide transaction ID and PIN'
      });
    }

    // Find transaction with customer data
    const transaction = await Transaction.findOne({
      transactionId: transactionId
    }).populate('customerId').session(session);

    if (!transaction) {
      await session.abortTransaction();
      session.endSession();
      return res.status(404).json({
        success: false,
        message: 'Transaction not found'
      });
    }

    // Check if already processed
    if (transaction.status !== 'PENDING') {
      await session.abortTransaction();
      session.endSession();
      return res.status(400).json({
        success: false,
        message: `Transaction already ${transaction.status.toLowerCase()}`
      });
    }

    // Check pin attempts
    if (transaction.pinAttempts >= 3) {
      transaction.status = 'FAILED';
      transaction.errorMessage = 'Maximum PIN attempts exceeded';
      transaction.updatedAt = new Date();
      await transaction.save({ session });

      await session.commitTransaction();
      session.endSession();

      return res.status(400).json({
        success: false,
        message: 'Maximum PIN attempts exceeded. Transaction failed.'
      });
    }

    // Find customer
    const customer = await Customer.findById(transaction.customerId._id).session(session);
    if (!customer) {
      await session.abortTransaction();
      session.endSession();
      return res.status(404).json({
        success: false,
        message: 'Customer not found'
      });
    }

    // Validate PIN (demo: ONLY ACCEPT 1234)
    if (pin === '1234') {
      // Successful payment
      let mpesaReceiptNumber;
      try {
        if (typeof Transaction.generateMpesaReceiptNumber === 'function') {
          mpesaReceiptNumber = Transaction.generateMpesaReceiptNumber();
        } else {
          mpesaReceiptNumber = `MPESA${Date.now().toString().slice(-8)}${Math.floor(Math.random() * 10000).toString().padStart(4, '0')}`;
        }
      } catch (error) {
        mpesaReceiptNumber = `RC${Date.now().toString().slice(-10)}`;
      }

      // Update transaction
      transaction.status = 'SUCCESS';
      transaction.mpesaReceiptNumber = mpesaReceiptNumber;
      transaction.processedAt = new Date();
      transaction.updatedAt = new Date();
      transaction.pinAttempts += 1;

      // Update customer
      customer.loanBalance = transaction.loanBalanceAfter;
      customer.arrears = transaction.arrearsAfter;
      customer.totalRepayments += transaction.amount;
      customer.lastPaymentDate = new Date();
      customer.updatedAt = new Date();

      // Save both in transaction
      await transaction.save({ session });
      await customer.save({ session });

      await session.commitTransaction();
      session.endSession();

      // Response
      res.json({
        success: true,
        message: 'Payment successful!',
        data: {
          receipt: mpesaReceiptNumber,
          amount: transaction.amount,
          newLoanBalance: customer.loanBalance,
          newArrears: customer.arrears,
          transactionId: transaction.transactionId,
          transactionDate: transaction.processedAt
        }
      });
    } else {
      // Failed payment - increment attempt counter
      transaction.pinAttempts += 1;
      transaction.updatedAt = new Date();

      // Check if this was the final attempt
      if (transaction.pinAttempts >= 3) {
        transaction.status = 'FAILED';
        transaction.errorMessage = 'Maximum PIN attempts exceeded';
      }

      await transaction.save({ session });
      await session.commitTransaction();
      session.endSession();

      const attemptsLeft = 3 - transaction.pinAttempts;

      res.status(400).json({
        success: false,
        message: `Invalid MPesa PIN. ${attemptsLeft > 0 ? `You have ${attemptsLeft} attempt(s) left.` : 'Maximum attempts exceeded.'}`,
        data: {
          attemptsLeft: Math.max(0, attemptsLeft)
        }
      });
    }
  } catch (error) {
    await session.abortTransaction();
    session.endSession();

    console.error('Process PIN error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error processing payment'
    });
  }
};


/**
 * @desc    Get recent transactions for dashboard
 * @route   GET /api/payments/recent-transactions
 * @access  Private (Admin, Supervisor, Agent)
 */
exports.getRecentTransactions = async (req, res) => {
  try {
    const transactions = await Transaction.find()
      .populate('customerId', 'name phoneNumber')
      .sort({ createdAt: -1 })
      .limit(5)
      .select('transactionId customerId amount status phoneNumber createdAt description paymentMethod');
    
    res.json({
      success: true,
      data: {
        transactions: transactions || []
      }
    });
  } catch (error) {
    console.error('Error fetching recent transactions:', error);
    res.status(500).json({
      success: false,
      message: 'Server error fetching recent transactions'
    });
  }
};



/**
 * @desc    Get transaction status
 * @route   GET /api/payments/status/:transactionId
 * @access  Private (Admin, Supervisor, Agent)
 */
exports.getTransactionStatus = async (req, res) => {
  try {
    const transaction = await Transaction.findOne({
      transactionId: req.params.transactionId
    }).populate('customerId', 'name phoneNumber').select('-__v');

    if (!transaction) {
      return res.status(404).json({
        success: false,
        message: 'Transaction not found'
      });
    }

    res.json({
      success: true,
      data: { transaction }
    });
  } catch (error) {
    console.error('Get transaction status error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error fetching transaction status'
    });
  }
};

/**
 * @desc    Get all transactions with pagination and filtering
 * @route   GET /api/payments/transactions
 * @access  Private (Admin, Supervisor, Agent)
 */
exports.getTransactions = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 20,
      status,
      startDate,
      endDate,
      customerId,
      phoneNumber
    } = req.query;

    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const skip = (pageNum - 1) * limitNum;

    // Build query
    const query = {};

    if (status) {
      query.status = status;
    }

    if (customerId) {
      const customer = await Customer.findOne({
        $or: [
          { _id: customerId },
          { customerId: customerId },
          { customerInternalId: customerId }
        ]
      });

      if (customer) {
        query.customerId = customer._id;
      }
    }

    if (phoneNumber) {
      const formattedPhone = formatPhoneNumber(phoneNumber);
      query.phoneNumber = formattedPhone;
    }

    // Date filtering
    if (startDate || endDate) {
      query.createdAt = {};
      if (startDate) {
        query.createdAt.$gte = new Date(startDate);
      }
      if (endDate) {
        query.createdAt.$lte = new Date(endDate);
      }
    }

    // Execute queries in parallel
    const [transactions, total, successful, totalAmount] = await Promise.all([
      Transaction.find(query)
        .populate('customerId', 'name phoneNumber customerId')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limitNum)
        .select('-__v'),
      Transaction.countDocuments(query),
      Transaction.countDocuments({ ...query, status: 'SUCCESS' }),
      Transaction.aggregate([
        { $match: { ...query, status: 'SUCCESS' } },
        { $group: { _id: null, totalAmount: { $sum: '$amount' } } }
      ])
    ]);

    const summaryAmount = totalAmount[0] ? totalAmount[0].totalAmount : 0;

    res.json({
      success: true,
      data: {
        transactions,
        summary: {
          total,
          successful,
          totalAmount: summaryAmount,
          successRate: total > 0 ? (successful / total * 100).toFixed(2) : 0
        },
        pagination: {
          total,
          page: pageNum,
          limit: limitNum,
          pages: Math.ceil(total / limitNum)
        }
      }
    });
  } catch (error) {
    console.error('Get transactions error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error fetching transactions'
    });
  }
};

/**
 * @desc    Check and expire old pending transactions (cron job)
 * @route   N/A (Runs automatically)
 * @access  Private (System)
 */
exports.checkExpiredTransactions = async () => {
  try {
    const thirtySecondsAgo = new Date(Date.now() - 30000); // 30 seconds

    // FIXED: Use createdAt instead of stkPushSentAt
    const expiredTransactions = await Transaction.find({
      status: 'PENDING',
      createdAt: { $lt: thirtySecondsAgo }
    });

    if (expiredTransactions.length > 0) {
      console.log(`Found ${expiredTransactions.length} expired transactions`);

      for (const transaction of expiredTransactions) {
        transaction.status = 'EXPIRED';
        transaction.failureReason = 'EXPIRED';
        transaction.errorMessage = 'Payment request expired (30 seconds) - Customer did not respond';
        transaction.updatedAt = new Date();
        await transaction.save();
      }
    }
  } catch (error) {
    console.error('Error checking expired transactions:', error);
  }
};

// Helper function for failure messages
function getFailureMessage(failureReason) {
  const messages = {
    'INSUFFICIENT_FUNDS': 'Customer has insufficient funds in their MPESA account',
    'TECHNICAL_ERROR': 'Technical error occurred during payment processing',
    'WRONG_PIN': 'Incorrect MPESA PIN entered',
    'USER_CANCELLED': 'Customer cancelled the payment',
    'NETWORK_ERROR': 'Network error occurred',
    'EXPIRED': 'Payment request expired (30 seconds) - Customer did not respond',
    'OTHER': 'Payment failed due to unknown reasons'
  };

  return messages[failureReason] || 'Payment failed';
}

/**
 * @desc    Mark transaction as failed with specific reason
 * @route   POST /api/payments/mark-failed/:transactionId
 * @access  Private (Admin, Supervisor)
 */
exports.markTransactionFailed = async (req, res) => {
  try {
    const { failureReason } = req.body;

    if (!failureReason) {
      return res.status(400).json({
        success: false,
        message: 'Please provide a failure reason'
      });
    }

    const transaction = await Transaction.findOne({
      transactionId: req.params.transactionId,
      status: 'PENDING'
    });

    if (!transaction) {
      return res.status(404).json({
        success: false,
        message: 'Pending transaction not found'
      });
    }

    transaction.status = 'FAILED';
    transaction.failureReason = failureReason;
    transaction.errorMessage = getFailureMessage(failureReason);
    transaction.updatedAt = new Date();
    await transaction.save();

    res.json({
      success: true,
      message: 'Transaction marked as failed',
      data: { transaction }
    });
  } catch (error) {
    console.error('Mark transaction failed error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error marking transaction as failed'
    });
  }
};

/**
 * @desc    Cancel a pending transaction
 * @route   POST /api/payments/cancel/:transactionId
 * @access  Private (Admin, Supervisor)
 */
exports.cancelTransaction = async (req, res) => {
  try {
    const transaction = await Transaction.findOne({
      transactionId: req.params.transactionId,
      status: 'PENDING'
    });

    if (!transaction) {
      return res.status(404).json({
        success: false,
        message: 'Pending transaction not found or already processed'
      });
    }

    transaction.status = 'CANCELLED';
    transaction.updatedAt = new Date();
    transaction.errorMessage = 'Cancelled by administrator';
    await transaction.save();

    res.json({
      success: true,
      message: 'Transaction cancelled successfully',
      data: { transaction }
    });
  } catch (error) {
    console.error('Cancel transaction error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error cancelling transaction'
    });
  }
};

/**
 * @desc    Test endpoint to check if server is working
 * @route   GET /api/payments/test
 * @access  Public
 */
exports.testEndpoint = async (req, res) => {
  console.log('Test endpoint called');
  res.json({
    success: true,
    message: 'Payment API is working',
    timestamp: new Date(),
    environment: process.env.NODE_ENV,
    twilioConfigured: !!process.env.TWILIO_ACCOUNT_SID
  });
};

/**
 * @desc    Get dashboard statistics
 * @route   GET /api/payments/dashboard/stats
 * @access  Private (Admin, Supervisor)
 */
exports.getDashboardStats = async (req, res) => {
  try {
    // Get today's date
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    // Get statistics
    const [
      totalTransactions,
      successfulTransactions,
      pendingTransactions,
      failedTransactions,
      totalAmount,
      todayAmount,
      totalCustomers
    ] = await Promise.all([
      Transaction.countDocuments(),
      Transaction.countDocuments({ status: 'SUCCESS' }),
      Transaction.countDocuments({ status: 'PENDING' }),
      Transaction.countDocuments({ status: 'FAILED' }),
      Transaction.aggregate([
        { $match: { status: 'SUCCESS' } },
        { $group: { _id: null, totalAmount: { $sum: '$amount' } } }
      ]),
      Transaction.aggregate([
        {
          $match: {
            status: 'SUCCESS',
            createdAt: { $gte: today, $lt: tomorrow }
          }
        },
        { $group: { _id: null, totalAmount: { $sum: '$amount' } } }
      ]),
      Customer.countDocuments({ isActive: true })
    ]);

    const totalAmountValue = totalAmount[0] ? totalAmount[0].totalAmount : 0;
    const todayAmountValue = todayAmount[0] ? todayAmount[0].totalAmount : 0;
    const successRate = totalTransactions > 0 ? (successfulTransactions / totalTransactions * 100).toFixed(2) : 0;

    res.json({
      success: true,
      data: {
        totalTransactions,
        successfulTransactions,
        pendingTransactions,
        failedTransactions,
        totalAmount: totalAmountValue,
        todayAmount: todayAmountValue,
        totalCustomers,
        successRate: parseFloat(successRate)
      }
    });
  } catch (error) {
    console.error('Get dashboard stats error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error fetching dashboard statistics'
    });
  }
};

/**
 * @desc    Get transaction by ID
 * @route   GET /api/payments/transaction/:id
 * @access  Private (Admin, Supervisor, Agent)
 */
exports.getTransactionById = async (req, res) => {
  try {
    const transaction = await Transaction.findById(req.params.id)
      .populate('customerId', 'name phoneNumber customerId')
      .select('-__v');

    if (!transaction) {
      return res.status(404).json({
        success: false,
        message: 'Transaction not found'
      });
    }

    res.json({
      success: true,
      data: { transaction }
    });
  } catch (error) {
    console.error('Get transaction by ID error:', error);
    res.status(500).json({
      success: false,
      message: 'Server error fetching transaction'
    });
  }
};

/**
 * @desc    Debug transaction model
 * @route   GET /api/payments/debug-transaction
 * @access  Private (Admin, Supervisor, Agent)
 */
exports.debugTransactionModel = async (req, res) => {
  try {
    // Check if Transaction model has required methods
    const hasGenerateMethod = typeof Transaction.generateMpesaReceiptNumber === 'function';

    // Check a sample transaction
    const sampleTransaction = await Transaction.findOne().sort({ createdAt: -1 });

    res.json({
      success: true,
      data: {
        modelInfo: {
          hasGenerateMpesaReceiptNumber: hasGenerateMethod,
          modelName: Transaction.modelName
        },
        sampleTransaction: sampleTransaction ? {
          id: sampleTransaction._id,
          transactionId: sampleTransaction.transactionId,
          status: sampleTransaction.status,
          paymentMethod: sampleTransaction.paymentMethod,
          pinAttempts: sampleTransaction.pinAttempts
        } : null
      }
    });
  } catch (error) {
    console.error('Debug error:', error);
    res.status(500).json({
      success: false,
      message: 'Debug error: ' + error.message
    });
  }
};

// Schedule cron job to check for expired transactions every 10 seconds
cron.schedule('*/10 * * * * *', () => {
  console.log('Checking for expired transactions...');
  exports.checkExpiredTransactions();
});

module.exports = exports;